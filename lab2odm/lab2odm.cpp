#define _CRT_SECURE_NO_WARNINGS

#include <iostream>

int main()
{
	int** G, ** H; // пустые множества, лягут в основу графиков, над которыми будут выполняться операции
	int cardnumG, cardnumH;
	printf("Moschnost' grafika G: ");
	scanf("%d", &cardnumG);
	G = new int* [cardnumG]; // мощность графика G приравнивается к введённому пользователем значению
	for (int i = 0; i < cardnumG; i++)
	{
		G[i] = new int[2]; // каждый элемент графика - кортеж длины 2
		printf("Vvedite %d paru grafika G: ", i+1);
		scanf("%d %d", &(G[i][0]), &(G[i][1])); // пользователь вводит i-тую пару графика G
	}
	printf("Moschnost' grafika H: ");
	scanf("%d", &cardnumH);
	H = new int* [cardnumH]; // мощность графика H приравниваетяс к введённому пользователем значению
	for (int i = 0; i < cardnumH; i++)
	{
		H[i] = new int[2]; // каждый элемент графика - кортеж длины 2
		printf("Vvedite %d paru grafika H: ", i + 1);
		scanf("%d %d", &(H[i][0]), &(H[i][1])); // пользователь вводит j-тую пару графика H
	}

	printf("\n\n");

	int** J = new int*[61]; // пустой график, который ляжет в основу графика, являющегося объединением
	int currindex = 0;
	for (int i = 0; i < cardnumH; i++)
	{
		J[currindex++] = H[i]; // в график J записываются все пары графика H
	}
	for (int i = 0; i < cardnumG; i++) // каждой паре графика G...
	{
		for (int j = 0; j < cardnumH; j++) // ...поочерёдно ставится в соответствие каждая пара из графика H,..
		{
			if (G[i][0] == H[j][0]) // ...и если первый элемент текущей пары графика G равен первому элементу текущей пары графика H... 
			{
				if (G[i][1] == H[j][1]) // ...и второй элемент текущей пары графика G равен второму элементу текущей пары графика H,..
				{
					goto uninext; // ...рассматривается следующая пара графика G,..
				}
			}
		}
		J[currindex] = new int[2];
		J[currindex][0] = G[i][0];
		J[currindex++][1] = G[i][1]; // ...а иначе - текущая пара графика G записывается в график J
		uninext:;
	}
	printf("Ob'edinenie: { ");
	for (int i = 0; i < currindex; i++)
	{
		printf("<%d, %d> ", J[i][0], J[i][1]); // график, являющийся объединением G и H, выводится на экран
	}
	printf("}");

	printf("\n\n");

	J = new int* [31]; // пустой график, который ляжет в основу графика, являющегося пересечением G и H
	currindex = 0;
	for (int i = 0; i < cardnumG; i++) // каждой паре графика G...
	{
		for (int j = 0; j < cardnumH; j++) // ...поочерёдно ставится в соответствие каждая пара из графика H,..
		{
			if (G[i][0] == H[j][0]) // ...и если первый элемент текущей пары графика G равен первому элементу текущей пары графика H... 
			{
				if (G[i][1] == H[j][1]) // ...и второй элемент текущей пары графика G равен второму элементу текущей пары графика H,..
				{
					int* temp = new int[2];
					temp[0] = G[i][0];
					temp[1] = G[i][1];
					J[currindex++] = temp; // ...текущая пара графика G записывается в график J
				}
			}
		}
	}
	printf("Peresechenie: { ");
	for (int i = 0; i < currindex; i++)
	{
		printf("<%d, %d> ", J[i][0], J[i][1]); // график, являющийся пересечением G и H, выводится на экран
	}
	printf("}");

	printf("\n\n");

	J = new int* [31]; // пустой график, который ляжет в основу графика, являющегося разностью G и H
	currindex = 0;
	for (int i = 0; i < cardnumG; i++) // каждой паре графика G...
	{
		for (int j = 0; j < cardnumH; j++) // ...поочерёдно ставится в соответствие каждая пара из графика H,..
		{
			if (G[i][0] == H[j][0]) // ...и если первый элемент текущей пары графика G равен первому элементу текущей пары графика H... 
			{
				if (G[i][1] == H[j][1]) // ...и второй элемент текущей пары графика G равен второму элементу текущей пары графика H,..
				{
					goto diffnextgh; // ...рассматривается следующая пара графика G,..
				}
			}
		}
		J[currindex] = new int[2];
		J[currindex][0] = G[i][0];
		J[currindex++][1] = G[i][1]; // ...а иначе - текущая пара графика G записывается в график J
		diffnextgh:;
	}
	printf("Raznost' G\\H: { ");
	for (int i = 0; i < currindex; i++)
	{
		printf("<%d, %d> ", J[i][0], J[i][1]); // график, являющийся разностью G и H, выводится на экран
	}
	printf("}");

	printf("\n\n");

	J = new int* [31]; // пустой график, который ляжет в основу графика, являющегося разностью H и G
	currindex = 0;
	for (int i = 0; i < cardnumH; i++) // каждой паре графика H...
	{
		for (int j = 0; j < cardnumG; j++) // ...поочерёдно ставится в соответствие каждая пара из графика G,..
		{
			if (H[i][0] == G[j][0]) // ...и если первый элемент текущей пары графика H равен первому элементу текущей пары графика G... 
			{
				if (H[i][1] == G[j][1]) // ...и второй элемент текущей пары графика H равен второму элементу текущей пары графика G,..
				{
					goto diffnexthg; // ...рассматривается следующая пара графика H,..
				}
			}
		}
		J[currindex] = new int[2];
		J[currindex][0] = H[i][0];
		J[currindex++][1] = H[i][1]; // ...а иначе - текущая пара графика H записывается в график J
		diffnexthg:;
	}
	printf("Raznost' H\\G: { ");
	for (int i = 0; i < currindex; i++)
	{
		printf("<%d, %d> ", J[i][0], J[i][1]); // график, являющийся разностью H и G, выводится на экран
	}
	printf("}");

	printf("\n\n");

	J = new int* [61]; // пустой график, который ляжет в основу графика, являющегося симметрической разностью G и H
	currindex = 0;
	for (int i = 0; i < cardnumG; i++) // каждой паре графика G...
	{
		for (int j = 0; j < cardnumH; j++) // ...поочерёдно ставится в соответствие каждая пара из графика H,..
		{
			if (G[i][0] == H[j][0]) // ...и если первый элемент текущей пары графика G равен первому элементу текущей пары графика H... 
			{
				if (G[i][1] == H[j][1]) // ...и второй элемент текущей пары графика G равен второму элементу текущей пары графика H,..
				{
					goto symmdiffnext1; // ...рассматривается следующая пара графика G,..
				}
			}
		}
		J[currindex] = new int[2];
		J[currindex][0] = G[i][0];
		J[currindex++][1] = G[i][1]; // ...а иначе - текущая пара графика G записывается в график J
		symmdiffnext1:;
	}
	for (int i = 0; i < cardnumH; i++) // каждой паре графика H...
	{
		for (int j = 0; j < cardnumG; j++) // ...поочерёдно ставится в соответствие каждая пара из графика G,..
		{
			if (H[i][0] == G[j][0]) // ...и если первый элемент текущей пары графика H равен первому элементу текущей пары графика G... 
			{
				if (H[i][1] == G[j][1]) // ...и второй элемент текущей пары графика H равен второму элементу текущей пары графика G,..
				{
					goto symmdiffnext2; // ...рассматривается следующая пара графика H,..
				}
			}
		}
		J[currindex] = new int[2];
		J[currindex][0] = H[i][0];
		J[currindex++][1] = H[i][1]; // ...а иначе - текущая пара графика H записывается в график J
		symmdiffnext2:;
	}
	printf("Simmetricheskaya raznost': { ");
	for (int i = 0; i < currindex; i++)
	{
		printf("<%d, %d> ", J[i][0], J[i][1]); // график, являющийся симметрической разностью G и H, выводится на экран
	}
	printf("}");

	printf("\n\n");

	J = new int* [31]; // пустой график, который ляжет в основу инверсии графика G
	for (int i = 0; i < cardnumG; i++) // для каждой пары графика G...
	{
		J[i] = new int[2]; // в график J записывается пара,..
		J[i][0] = G[i][1]; // первый элемент которой - второй элемент текущей пары графика G,..
		J[i][1] = G[i][0]; // а второй элемент - первый элемент текущей пары графика G
	}
	printf("Inversiya G: { ");
	for (int i = 0; i < cardnumG; i++)
	{
		printf("<%d, %d> ", J[i][0], J[i][1]); // график, являющийся инверсией G, выводится на экран
	}
	printf("}");
	
	printf("\n\n");

	J = new int* [31]; // пустой график, который ляжет в основу инверсии графика H
	for (int i = 0; i < cardnumH; i++) // для каждой пары графика H...
	{
		J[i] = new int[2]; // в график J записывается пара,..
		J[i][0] = H[i][1]; // первый элемент которой - второй элемент текущей пары графика H,..
		J[i][1] = H[i][0]; // а второй элемент - первый элемент текущей пары графика H
	}
	printf("Inversiya H: { ");
	for (int i = 0; i < cardnumH; i++)
	{
		printf("<%d, %d> ", J[i][0], J[i][1]); // график, являющийся инверсией H, выводится на экран
	}
	printf("}");

	printf("\n\n");

	J = new int* [61]; // пустой график, который ляжет в основу графика, являющегося композицией графиков G и H
	int cardnumJ = 0; // мощность графика J равна 0
	for (int i = 0; i < cardnumG; i++) // каждой паре из графика G...
	{
		for (int j = 0; j < cardnumH; j++) // ...поочерёдно ставится в соответствие каждая пара из графика H,..
		{
			if (G[i][1] == H[j][0]) // ...и если второй элемент текущей пары графика G равен первому элементу текущей пары графика H,..
			{
				int* p = new int[2]; // ...создаётся пустая пара p
				p[0] = G[i][0]; // первому элементу пары p присваивается значение первого элемента текущей пары графика G
				p[1] = H[j][1]; // второму элементу пары p присваивается значение второго элемента текущей пары графика H
				for (int k = 0; k < cardnumJ; k++) // во всех на данный момент имеющихся парах графика J поочерёдно выполняется проверка:..
				{
					if (p[0] == J[k][0]) // ...если первый элемент пары p равен первому элементу текущей пары графика J...
					{
						if (p[1] == J[k][1]) // и второй элемент пары p равен второму элементу текущей пары графика J,..
						{
							goto compositionnextgh; // рассматривается следующая пара графика G,..
						}
					}
				}
				J[cardnumJ++] = p; // а иначе - пара p записывается в график J
			}
		}
		compositionnextgh:;
	}
	printf("Kompositsiya G i H: { ");
	for (int i = 0; i < cardnumJ; i++)
	{
		printf("<%d, %d> ", J[i][0], J[i][1]); // график, являющийся композицией G и H, выводится на экран
	}
	printf("}");

	printf("\n\n");

	J = new int* [61]; // пустой график, который ляжет в основу графика, являющегося композицией графиков H и G
	cardnumJ = 0; // мощность графика J равна 0
	for (int i = 0; i < cardnumH; i++) // каждой паре из графика H...
	{
		for (int j = 0; j < cardnumG; j++) // ...поочерёдно ставится в соответствие каждая пара из графика G,..
		{
			if (H[i][1] == G[j][0]) // ...и если второй элемент текущей пары графика G равен первому элементу текущей пары графика G,..
			{
				int* p = new int[2]; // ...создаётся пустая пара p
				p[0] = H[i][0]; // первому элементу пары p присваивается значение первого элемента текущей пары графика H
				p[1] = G[j][1]; // второму элементу пары p присваивается значение второго элемента текущей пары графика G
				for (int k = 0; k < cardnumJ; k++) // во всех на данный момент имеющихся парах графика J поочерёдно выполняется проверка:..
				{
					if (p[0] == J[k][0]) // ...если первый элемент пары p равен первому элементу текущей пары графика J...
					{
						if (p[1] == J[k][1]) // и второй элемент пары p равен второму элементу текущей пары графика J,..
						{
							goto compositionnexthg; // рассматривается следующая пара графика H,..
						}
					}
				}
				J[cardnumJ++] = p; // а иначе - пара p записывается в график J
			}
		}
		compositionnexthg:;
	}
	printf("Kompositsiya H i G: { ");
	for (int i = 0; i < cardnumJ; i++)
	{
		printf("<%d, %d> ", J[i][0], J[i][1]); // график, являющийся композицией H и G, выводится на экран
	}
	printf("}");

	printf("\n\n");
	return 0; // алгоритм завершает работу
}